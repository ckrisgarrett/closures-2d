\documentclass{article}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tabu}
\usepackage{commath}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usepackage[section]{placeins}
\usepackage{nth}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{defs}
\usepackage{fonts}

\newcommand{\main}{\texttt{main.cpp}\xspace}
\newcommand{\comm}{\texttt{comm.cpp}\xspace}
\newcommand{\utils}{\texttt{utils.cpp}\xspace}
\newcommand{\timer}{\texttt{timer.cpp}\xspace}
\newcommand{\inputdeck}{\texttt{input.deck}\xspace}
\newcommand{\kineticdeck}{\texttt{kinetic.deck}\xspace}
\newcommand{\floor}{\ensuremath{\mathtt{c\_floor}}\xspace}
\newcommand{\quadorder}{\ensuremath{\mathtt{quadOrder}}\xspace}
\newcommand{\dn}{\texttt{dn}\xspace}
\newcommand{\integer}{\texttt{int}\xspace}
\newcommand{\bool}{\texttt{bool}\xspace}
\newcommand{\float}{\texttt{float}\xspace}
\newcommand{\double}{\texttt{double}\xspace}
\newcommand{\chars}{\texttt{char[]}\xspace}
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}\xspace}
\newcommand{\R}{\ensuremath{\mathbb{R}}\xspace}
\newcommand{\C}{\ensuremath{\mathbb{C}}\xspace}
\newcommand{\assign}{\ensuremath{\mathrel{\texttt{:=}}}}
\DeclareMathOperator{\minmod}{minmod}
\DeclareMathOperator{\slopefit}{slopefit}
\DeclareMathOperator{\sgn}{sgn}
%\DeclareMathOperator*{\argmin}{arg\,min}
%\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\integral}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\closure}[1]{\ensuremath{\mathcal{E}(#1)}}
\newcommand{\twosphere}{\ensuremath{\mathbb{S}^2}\xspace}
\newcommand{\threespace}{\ensuremath{\mathbb{R}^3}\xspace}
\newcommand{\kinetic}{\texttt{kinetic}\xspace}
\newcommand{\moment}{\texttt{moment}\xspace}
\newcommand{\momopt}{\texttt{momopt}\xspace}

\frenchspacing
%\raggedright

\AtBeginDocument{\let\textlabel\label}

\title{\texttt{closures-2d} \\ Design Documentation}
\author{C. Kristopher Garrett, Tim Shaffer}

\begin{document}
\maketitle
\tableofcontents

\section{Purpose}
This software implements various numerical methods for
approximating the angular variable in kinetic transport in order
to study performance, accuracy, and robustness on common test problems.
Whereas fluid equations describe a vector of quantities dependent on space,
kinetic transport equations describe a scalar density of particles
depending on both space and velocity. Such numerical methods occur
frequently in production codes modeling certain physical systems, such as
neutron transport inside a reactor, neutrino transport in supernova simulations,
photon transport, and rarefied gas dynamics. Rather than simulating a
specific physical system, this software solves simpler problems that capture
issues commonly encountered in full simulations. Comparing the performance of
these numerical methods on our simplified problems can give researchers
insight into the behavior of similar methods in more complicated
implementations.

In addition to evaluating the methods themselves, this
software is written to allow study of
performance with modern high-performance computing resources. This software
optionally uses OpenMP and Message Passing Interface~(MPI) to carry
out parallel and concurrent computations. Studying the behavior of
numerical methods with such acceleration techniques provides reference for
implementations on large-scale problems.

This software also supports profiling measurements such as timings, flop rates,
memory rates, and cache misses. Using statistics about runtime performance,
we examined code optimizations, bottlenecks, etc. that occur
in our implementations.

\section{Problem}
This software simulates particles with unit speed that scatter isotropically according to a simple kinetic equation. 
The equation governing particle behavior takes the form
\begin{align}
    \label{eqn:kinetic}
    \partial_t f + \Omega \cdot \nabla_x f + \sigma_t f =
    \frac{\sigma_s}{4\pi} \integral{f}
\end{align}
where $f(x,\Omega,t)$ is the density of particles, $x \in \mathcal{D} \subset \mathbb{R}^2$ is position, $\Omega \in \twosphere \subset \threespace$ (the unit sphere)
is the direction of travel, $\sigma_t(x) \geq \sigma_s(x)$ are the total and scattering cross sections, and
\integral{\cdot} is shorthand for integration over \twosphere.
The boundary conditions implemented are either zero inflow boundary conditions or periodic boundary conditions depending on the initial condition discussed in Section~\ref{subsec:initcond}.

%The \kinetic solver directly computes solutions to
%Equation~\ref{eqn:kinetic}, while the \moment solver calculates solutions based on
%the spherical harmonic basis functions. The \momopt solver includes additional
%optimizations and experimental features. This program explicitly computes approximate
%solutions to Equation~\ref{eqn:kinetic} as
%the system evolves from one of several initial conditions, defined in
%Section~\ref{sec:initcond}.

\subsection{Initial Conditions}
\label{subsec:initcond}
\FloatBarrier
The following initial conditions are implemented in this software.

\subsubsection{Gaussian Initial Condition}
\begin{figure}
    \centering
    \includegraphics[height=0.3\textheight]{initcond_gaussian.png}
    \caption{Gaussian Initial Condition}
    \label{fig:gaussian_ic}
\end{figure}
In the Gaussian initial condition, a two dimensional Gaussian function
is placed with its peak at the center of the grid. Each point on the
initial grid is set to
\begin{equation}
    f(x,y,\Omega,0) = \max \left( \frac{1}{2 \pi \sigma_g^2} e^{-(x^2 + y^2) / (2 \sigma_g^2)}, \texttt{floor} \right), 
\end{equation}
where $\sigma_g$ is set by the user.
The cross sections $\sigma_s$ and $\sigma_t$ are constants defined by the user.
The zero inflow boundary condition is used.
Figure~\ref{fig:gaussian_ic} shows the initial condition of $\vint{f}$ for $\sigma_g = ???$. 
\comment{Follow this pattern for other initial conditions.}

\subsubsection{Delta Initial Condition}
The limiting case, as $\sigma \to 0$, is the
Delta initial condition. For this condition, the centermost cell is set to
$\frac{1}{\Delta x \Delta y}$ where $\Delta x$ and $\Delta y$ are the cell
dimensions. $\sigma_S$ and $\sigma_T$ are uniformly set to the configured
value for sigma.

\subsubsection{Lattice Initial Condition}
\begin{figure}
    \centering
    \includegraphics[height=0.3\textheight]{initcond_lattice-t.png}
    \caption{$\sigma_T$ for Lattice Initial Condition}
    \label{fig:lattice_ic}
\end{figure}
The Lattice initial condition corresponds to a checker board pattern
of highly scattering and highly absorbing regions. This configuration is reminiscent of a
small section of a nuclear reactor core. The Lattice initial condition leaves the
grid initially empty, but has the most complicated scattering pattern of the initial
conditions. $\sigma_S$ and $\sigma_T$ are set to 1 at all positions, except
for several blocks arranged throughout the grid at which $\sigma_S=0$ and
$\sigma_T=10$.
\comment{State the source too.}

\subsubsection{Smooth Initial Condition}
\begin{figure}
    \centering
    \includegraphics[height=0.3\textheight]{initcond_smooth.png}
    \caption{Smooth Initial Condition}
    \label{fig:smooth_ic}
\end{figure}
The Smooth initial condition is primarily intended for testing convergence.
This configuration initializes the grid points with a periodic boundary.
Each point in the initial grid is set to
\begin{align}
1 + \sin(2\pi x)\cos(2\pi y).
\end{align}
$\sigma_S$ and $\sigma_T$ are uniformly set to the configured
value for sigma.


\section{Angular Approximations}
\subsection{Discrete Ordinates}
The \kinetic solver is an implementation of the discrete ordinates method, also known
as $\mathrm{S}_N$.
Our implementation uses a Chebyshev-Legendre quadrature on the unit sphere.
A Lebedev quadrature is also implemented for this solver,
but is considered experimental.
Details of the quadratures are given in Section~\ref{subsec:quadratures}. Let
$\{\Omega_1, \dots, \Omega_Q\} \in \twosphere$ be be a set of nodes with
corresponding weights $\{w_1, \dots, w_Q\}$. Then from Equation~\ref{eqn:kinetic}
\begin{equation}
    \partial_t f_q + \Omega_q \cdot \nabla_x f_q + \sigma_t f_q=
    \frac{\sigma_s}{4\pi} \sum_{q'=1}^Q w_{q'} f_{q'},
\end{equation}
where $f_q(x,t) \approx f(x, \Omega_q, t)$ for $q = 1, \dots, Q$.

This implementation uses Heun's method to achieve second order convergence. Edge values
are computed via upwinding. For approximate slopes, the double minmod limiter is used.

\subsection{Moment Solvers}
\comment{Show basic setup. Then define $\mathcal{E}(\bu)$ for each type.}
The \moment solver uses standard spectral methods with Equation~\ref{eqn:kinetic}. The real
spherical harmonics serve as an orthonormal basis of $L^2$ with respect to
\twosphere for the expansion of the moments. Let
$\mathbf{m}(\Omega) =
(Y_{0,0}, Y_{1,-1}, Y_{1,0}, Y_{1,1}, \dots, Y_{N,-N}, \dots, Y_{N,N})^T$
be a vector of spherical harmonics up to and including degree $N$. The moments
with respect to $\mathbf{m}$ are given by
\begin{equation}
    \mathbf{u}^{\textrm{exact}}(\mathbf{x}, t) =
    \integral{\mathbf{m}(\Omega) f(\mathbf{x}, \Omega, t)}
\end{equation}
since $u_{\ell,m} = f_{\ell,m}$ and the collision operator is diagonalized.
\comment{Separate exact u from approximate u.}
The exact moment system is given by
\begin{equation}
    \partial_t \mathbf{u} + \nabla_x \cdot \integral{\Omega\mathbf{m}f} =
    \Dif \mathbf{u},
\end{equation}
but this formulation is not closed. Thus $f$ is replaced with a $\mathrm{P}_N$
moment closure $\closure{\mathbf{u}}$ such that
$\integral{\mathbf{m}\closure{\mathbf{u}}} = \mathbf{u}$. In this case,
\begin{equation}
    \closure{\mathbf{u}} = \sum_k u_k m_k = \mathbf{u}^T \mathbf{m}
\end{equation}
yielding the closed moment system
\begin{equation}
    \partial_t \mathbf{u} + \nabla_x \cdot
    \integral{\Omega\mathbf{m}\closure{\mathbf{u}}} = \Dif \mathbf{u}.
\end{equation}
It is only necessary to use the spherical harmonics $Y_{\ell,m}$ such that
$\ell + m$ is even. \comment{State why...}



\subsubsection{Entropy Minimization}
Suppose $\closure{\bu}$ is obtained as an entropy minimization
\begin{equation}
    \label{eqn:entropy}
    \mathcal{E}(\mathbf{u}) = \argmin_{g \in L^1} \integral{\eta(g)} \quad
    \textnormal{subject to} \quad \integral{\mathbf{m}g} = \mathbf{u}
\end{equation}
\comment{Fill in the rest here.}



\subsubsection{P$_N$}
$\closure{\bu} = \bm^T \bu$.
Can get this by (1) truncating, (2) least squares, (3) minimizing entropy.
\comment{Fill in a little bit.}

Various filters can also be applied to suppress oscillations in spherical harmonics.

\begin{itemize}
    \item The Hauck filter is described in \cite{Hauck-McClarren-2010}.
    Let $N$ be the moment order and $\omega$ be the filter tune, and define
    \begin{equation}
        \alpha = \frac{\omega}{N^2 (\sigma_T L + N)^2}.
    \end{equation}
    Scale each moment by
    \begin{equation}
        \frac{1}{1 + \alpha n^2 (n+1)^2}
    \end{equation}
    for the $n$\textsuperscript{th} moment.

    \item The Spline filter is given in \cite{Radice-2013}.
    With moment order $N$ and filter tune $\sigma_e$, let
    \begin{equation}
        s = \frac{-\sigma_e \Delta t}{\log F(N/(N+1))}
    \end{equation}
    where $F(x) = 1/(1 + x^4)$. The scale factor is given by
    \begin{equation}
        F(n/(N+1))^s.
    \end{equation}

    \item The Lanczos filter is taken from (insert citation).
    Again with moment order $N$ and filter tune $\sigma_e$, let
    \begin{equation}
        s = \frac{-\sigma_e \Delta t}{\log L(N / (N+1))}
    \end{equation}
    where
    \begin{equation}
        L(x) = \begin{dcases*}
            1 & when $x=0$ \\
            \frac{\sin x}{x} & otherwise.
        \end{dcases*}
    \end{equation}
    Now the moment scale factor is
    \begin{equation}
        L(n / (N+1))^s.
    \end{equation}
\end{itemize}

\subsection{M$_N$ and PP$_N$}
One serious drawback of the P$_N$ method is the possibility of non-realizable
solutions with negative densities, oscillatory approximations of nonsmooth
solutions. 
\comment{Can just put the definitions for $\eta$ and other stuff here for M$_N$ and PP$_N$.}
\comment{Also, the link boxes are useful but ugly.  Get rid of them.}

Nonlinear approaches can ensure positivity,
but come with increased complexity and computational cost. In general,
entropy-based moment closures, like the \momopt solver, can be cast in the
framework of the following minimization problem
\begin{equation}
    \label{eqn:entropy}
    \mathcal{E}(\mathbf{u}) = \argmin_{g \in L^1} \integral{\eta(g)} \quad
    \textnormal{subject to} \quad \integral{\mathbf{m}g} = \mathbf{u}
\end{equation}
where $\eta$ is a smooth, strictly convex, coercive\footnote{We define a
function $\eta$ to be coercive if
$\lim_{r \to \infty} \frac{\eta(r)}{|r|} = \infty$} function. For the
\momopt solver, $\eta(\mathbf{r}) = \mathbf{r} \log \mathbf{r} - \mathbf{r}$
and its Legendre dual\footnote{The Legendre dual of $\eta$ is given by
$\eta_*(s) = rs - \eta(r)$ where $s = \eta'(r)$. By differentiating this
relation, one can show that $r = \eta'_*(s)$. Thus $\eta'$ and $\eta'_*$ are
inverses of each other.} $\eta*(\mathbf{s}) = \mathbf{e^s}$.

The solution to Equation~\ref{eqn:entropy}, if it exists, is given by
\begin{equation}
    \mathcal{E}(\mathbf{u}) = \eta'_*(\hat{\mathbf{\alpha}}(\mathbf{u})^T \mathbf{m})
\end{equation}
where $\eta_*$ is the Legendre dual of $\eta$ and $\hat{\mathbf{\alpha}}(\mathbf{u})$
solves the dual problem
\begin{equation}
    \hat{\mathbf{\alpha}}(\mathbf{u}) = \argmin_{\mathbf{\alpha} \in \R^n}
    \left\{ \integral{\eta_*(\mathbf{\alpha}^T\mathbf{m})} -
    \mathbf{\alpha}^T \mathbf{u} \right\}.
\end{equation}

\section{Implementation}
\subsection{Quadratures}
\label{subsec:quadratures}
\comment{Let's go over this.  Some of the wording is not quite right.}
The Chebyshev-Legendre quadrature \cite{atkinson-1982} is used for numerical integration over
\twosphere in all of the solvers. This quadrature is constructed from an
$n$ point Gauss-Legendre rule, which exactly integrates smooth functions of
order less than $2n-1$. Since this is a 2D code, it is only necessary
to integrate over the upper half of \twosphere, which is divided into
$n$~layers along the $z$ axis. Abscissae and weights from GSL are arranged
in a circle around \twosphere at each layer, giving $n^2$ points on the
upper half of \twosphere. The Chebyshev-Legendre quadrature is not optimal
with respect to number of points, but is simple to implement. The Lebedev
quadrature, for example, is optimal in number of points, and an experimental
implementation is available for the \kinetic solver. This quadrature, however,
uses a more complicated arrangement of points, making exploiting symmetries
in the integral more difficult. In addition, the points of the
Chebyshev-Legendre quadrature are simply the Cartesian product of $n$ angles
spaced around a circle and $n$ values of $z$. This structure could allow the
evaluation of integrals via the Chebyshev-Legendre quadrature to be optimized
more easily than the Lebedev quadrature, which is arranged nontrivially and
becomes denser with increasing order.
\comment{Write in implementation here.  Not in appendix.}

\subsection{Time}
Time steps are carried out via Heun's method which is an explicit two-stage Runge-Kutta method that is second order accurate. 
\comment{Write equation.}
Notice Heun's method is the average of two Euler steps which puts it into the category of a strong stability preserving (SSP) method.
SSP methods preserve properties satisfied by the Euler method.
In particular, the software uses this method to ensure positivity for some methods.

\subsection{Space}
\comment{All the implementation stuff should be here.  Not in the appendix.  Add proof of positivity for S$_N$ and M$_N$ and PP$_N$.}
Space is discretized using the finite volume method. The problem domain is
decomposed into a regular grid of cells with an additional halo of ghost cells
to enforce the boundary condition and allow synchronization with other nodes.
At each update, the program first computes the flux at each cell, then updates
the cell values according to the kinetic transport equation. Several of the
solvers guarantee positivity on the grid.

For the \kinetic solver (implementing $S_N$), the timestep
$\Delta t$ is chosen with respect to the cell size so as not to violate
the CFL condition. To eliminate the possibility of negative density due
to scattering, an additional term is included in the CFL check. % check on this

The \momopt solver also ensures positivity as part of the flux calculations.
The flux is based on an ansatz grid with strictly positive values. For $M_N$,
the ansatz grid value $a$ at each cell and direction is given by
\begin{equation}
    a = \exp (\alpha^T m).
\end{equation}
For $PP_N$,
\begin{equation}
a =
\begin{dcases}
    \frac{1}{2}k + \frac{1}{2}\sqrt{k^2 + 4\delta} & \text{if } k > 0 \\
    \frac{-\delta}{\frac{1}{2}k - \frac{1}{2}\sqrt{k^2 + 4\delta}} & \text{if } k \leq 0
\end{dcases}
\end{equation}
where $k = \alpha^T m$.

\subsection{Optimization Procedure}
\dots

\section{Program Layout}
\comment{Make this nicer.  Introduce each solver here (i.e. kinetic\_solver) as associated with for instance S$_N$.}
\comment{Describe binary file formats.}
All options controlling the runtime operation of the program reside in
\texttt{input.deck}. Comments prefixed with \texttt{\#} are allowed,
and options not used by the selected solver are ignored. Available options are
listed in Section~\ref{sec:options}, and example options for the various
solvers are included in the \texttt{examples/} directory.
The outputs are binary files with
extensions \texttt{.sn}, \texttt{.pn}, and \texttt{.opt}, depending on
the solver. Python code for reading and working with these files is provided
in \texttt{util/formats.py}.

The common functionality is split up among the files in \texttt{src/}.
\begin{itemize}
 \item \texttt{main.cpp} -- Entry point of program
 \item \texttt{comm.cpp} -- Controls MPI communication
 \item \texttt{utils.cpp} -- Helper functions used throughout the code
 \end{itemize}
The solver code has an approximately common layout, e.g. in \texttt{src/moment/}
\begin{itemize}
 \item \texttt{moment\_init.cpp} -- Read config, set up quadrature and filters, etc.
 \item \texttt{moment\_boundaries.cpp} -- Communicate boundary data with other nodes
 \item \texttt{moment\_update.cpp} -- Solve flux, update the grid with time, etc.
 \item \texttt{moment\_output.cpp} -- Write out results
\end{itemize}

\section{Results}
\dots

\clearpage
\appendix
\section{Gritty Details}
\comment{Most of this should not be here, but rather in the math section.}
\subsection{\main}
\label{src:main.cpp}
The main entry point for the program, \main, is responsible for reading the input
files dictating runtime behavior, setting up MPI, and running the chosen solver.
In addition, the grid initialization used by all solvers is defined here, so \main
controls the grid geometry and initial configuration. Program flow is as follows
\begin{enumerate}
    \item Determine the current node and total number of nodes. If MPI support is not
    compiled in, fall back to default values corresponding to the primary and
    only node.
    \item Read in the configuration stored in \inputdeck. This format is
    described in Section~\ref{file:input.deck}.
    \item Configure the solver. Solvers are described in Section~\ref{solver}.
    \item Set the domain of the current node.
    \item Initialize the grid.
    \item Run the solver over the specified time interval.
    \item Output data.
\end{enumerate}

The default grid initialization, \texttt{Solver::initializeGrid}, also resides
in \main. At present, all solvers use this
method. The grid is represented as a two dimensional array of floating point values.
The grids used in the program are larger than configured in \inputdeck; a border of
of a specified width of ghost cells is added outside the grid described in the
configuration. The center points of the cells are used for calculation of
initial conditions. Figure~\ref{fig:grid} illustrates this layout.
There are two other arrays of identical size storing $\sigma_S$ and $\sigma_T$
values. To initialize the grid, first set the the border cells to the
specified floor value, \floor, and then calculate the initial values for the
main cells.

\subsubsection{Delta Initial Condition}
\label{init:delta}
\comment{Probably need this text somewhere.}
When \texttt{INITCOND\_LINESOURCE} is specified with Gaussian $\sigma=0$, the
Delta Initial Condition applies. In this case, $\sigma_S$ and $\sigma_T$ for each
cell are set to $\sigma$. The cells of the initial grid are set to \floor,
with the exception of the centermost cell, %TODO check on this, not really sure
which is set to $1 / \Delta x \Delta y$ where $\Delta x$ and $\Delta y$ denote the
dimensions of each cell.

\subsubsection{Gaussian Initial Condition}
\label{init:gauss}
This condition is used when \texttt{INITCOND\_LINESOURCE} is selected as the the
initial condition and Gaussian $\sigma \neq 0$. Each cell's initial value is
set to $\max \{\texttt{gaussianFactor}, \floor\}$ where
\begin{equation}
    \mathtt{gaussianFactor} \assign \frac{1}{2\pi\sigma^2}
        \exp \left(- \frac{x_i^2 + y_j^2}{2\sigma^2}\right).
\end{equation}
$\sigma_S$ and $\sigma_T$ for each cell is set to $\sigma$.

\subsubsection{Lattice Initial Condition}
\label{init:lattice}
When \texttt{INITCOND\_LATTICE} is specified, each cell's initial value is set to
\floor, and $\sigma_S,\sigma_T \assign 1$. For any cell $(x_i,y_j)$ with
\begin{equation}
    \|(x_i,y_j) - (s_x, s_y)\|_\infty < 0.5
\end{equation}    
for some $(s_x,s_y) \in \{$
    % I don't like switching out of math mode here, but I need the line broken,
    % and since it's in a paragraph, I'll just leave it like this for now.
    (2.0,2.0), (2.0,0.0), (2.0,-2.0), (1.0,1.0), (1.0,-1.0),
    (0.0,-2.0), (-1.0,1.0), (-1.0,-1.0), (-2.0,2.0), (-2.0,0.0), (-2.0,-2.0)
$\}$, $\sigma_T$ is set to 10 and $\sigma_S$ is set to 0.

\subsubsection{Smooth Periodic Condition}
\label{init:smooth}
When \texttt{INITCOND\_PERIODIC} is selected, $\sigma_S, \sigma_T$ are initialized
to $\sigma$, and the initial value at each point $(x_I,y_j)$ is set to
\begin{equation}
    \sin(2\pi x_i) \cos(2\pi y_j) + 1.
\end{equation}

\begin{figure}
    \centering
    \begin{tikzpicture}[decoration={brace, amplitude=5}]
        \filldraw[fill=gray] (-5,-7) rectangle (5,7);
        \filldraw[fill=white] (-3,-5) rectangle (3,5);
        \draw[step=1] (-5,-7) grid (5,7);
        \draw[decorate] (-5,7.5) -- node[above=5] {\texttt{numGhostCells}} (-3,7.5);
        \draw[decorate] (5.5,7) -- node[rotate=90,below=5]
            {\texttt{numGhostCells}} (5.5,5);
        \draw[decorate] (-3,7.5) -- node[above=5] {\texttt{c\_sizeX}} (3,7.5);
        \draw[decorate] (5.5,5) -- node[rotate=90,below=5]
            {\texttt{c\_sizeX}} (5.5,-5);
        \draw (-5,-7.4) -- (-5,-7.6) node[below] {\texttt{c\_gX[0]}};
        \draw (-3,-7.4) -- (-3,-7.6) node[below] {\texttt{c\_gX[1]}};
        \draw (2,-7.4) -- (2,-7.6) node[below] {\texttt{c\_gX[2]}};
        \draw (4,-7.4) -- (4,-7.6) node[below] {\texttt{c\_gX[3]}};
        \draw (-5.4,-7) -- (-5.6,-7) node[above,rotate=90] {\texttt{c\_gY[0]}};
        \draw (-5.4,-5) -- (-5.6,-5) node[above,rotate=90] {\texttt{c\_gY[1]}};
        \draw (-5.4,4) -- (-5.6,4) node[above,rotate=90] {\texttt{c\_gY[2]}};
        \draw (-5.4,6) -- (-5.6,6) node[above,rotate=90] {\texttt{c\_gY[3]}};
        \foreach \x in {-4.5,-3.5,...,4.5}
        \foreach \y in {-6.5,-5.5,...,6.5}
            \fill (\x,\y) circle (0.05);
    \end{tikzpicture}

    \vspace{0.5cm}

    \caption{Grid layout}
    \label{fig:grid}
\end{figure}

\subsection{\comm}
\label{src:comm.cpp}
\comment{Maybe put how MPI works in Program Layout.  Also put OpenMP stuff in there too so the user knows what is sped up and how.}
When using MPI, \comm communicates boundary data between nodes.
\texttt{Solver::getInnerBoundaries} is first called to obtain grid data on the
boundaries of the current node's region of the domain. Next, each node trades boundary
data with its neighbors to the north, south, east, then west via
\texttt{MPI\_ISend} and \texttt{MPI\_IRecv}. Finally, the node calls \texttt{Solver::setOuterBoundaries}
to update its grid with the data from neighboring nodes.
\comment{Note scaling has not been tested for MPI.}

\subsection{\utils}
\label{src:utils.cpp}
\utils is mostly comprised of IO-related utility functions. In addition, there are
functions to compute the 1-norm of an arbitrary vector and to compute Gaussian weights and nodes using GSL.

\subsection{\timer}
\label{src:timer.cpp}
\timer contains a timer class used in \main to record the time taken by computations.

\section{Solvers}
\label{solver}
All solvers must store internal parameters and grid data, and implement methods to
initialize, query grid parameters, update, and output data. See \texttt{solver.h}
for more detail. Each solver is organized into a directory containing the necessary
functionality split across several files. The solvers currently implemented
are \kinetic, \moment, \momopt, and \dn.

\subsection{\kinetic}
\label{solver:kinetic}
\subsubsection{\texttt{kinetic\_init.cpp}}
\label{src:kinetic_init.cpp}
\kinetic reads its runtime configuration from the file \kineticdeck
(see Section~\ref{file:kinetic.deck}). The maximum $\Delta t$ value \texttt{maxDt}
is calculated as
\begin{equation} %TODO check on roundabout 1/2
    \mathtt{maxDt} \assign \frac{1}{2} (\mathtt{cflFactor})
        \frac{\Delta x \Delta y}{\Delta x + \Delta y}.
\end{equation}
The grid is initialized as described in Section~\ref{src:main.cpp}. In addition to
the grid layers common to all solvers, \kinetic uses two others, \texttt{c\_kinetic}
and \texttt{c\_flux}. \utils is used
to get the quadrature as described in Section~\ref{src:utils.cpp}. These fixed-order
Gauss-Legendre integration points and weights returned will be referred to as $\mu_i$,
and $w_i$, respectively. Next, the
azimuthal angles of quadrature, $\phi_k$, are calculated as
\begin{equation}
    \phi_k \assign \frac{(k + 0.5)\pi}{\quadorder}
\end{equation}
for $k \in \Z$ such that $0 \leq k < 2(\quadorder)$,
placing $2(\quadorder)$ points evenly around the unit circle.
The quadrature weights are ultimately stored in
\texttt{c\_quadWeights}, and the points are mapped into cylindrical coordinates
and stored in \texttt{c\_xi} and \texttt{c\_eta}.
%TODO make sure geometric description is correct

For $q_1,q_2$ such that $0 \leq q_1 < (\quadorder) / 2$ and
$0 \leq q_2 < 2(\quadorder)$, define a quadrature counter
$q \assign 2(\quadorder)q_1 + q_2$. Now 
\begin{align}
    \mathtt{c\_quadWeights[q]} &\assign \frac{2\pi w_{q_1}}{\quadorder} \\
    \mathtt{c\_xi[q]} &\assign \sqrt{1 - \mu_{q_1}^2} \cos \phi_{q_2} \\
    \mathtt{c\_eta[q]} &\assign \sqrt{1 - \mu_{q_1}^2} \sin \phi_{q_2}
\end{align}

\subsubsection{\texttt{kinetic\_update.cpp}}
\label{src:kinetic_update.cpp}
The core of the \kinetic solver is the \texttt{update} method defined here. Each
call to update one time step operates as follows:
\begin{enumerate}
    \item Make a copy of the \texttt{c\_kinetic} grid.
    \item Carry out the first Euler step.
    \item Carry out the second Euler step.
    \item Average the initial grid with the results of the second iteration.
\end{enumerate}
Some preliminary functions will be used in the discussion of the above steps.


\comment{The minmod preserves positivity.  Need to show this.}
The \texttt{minmod(double x, double y)} function is designed to return
\begin{itemize}
    \item 0 if $xy < 1$
    \item $\min\{x, y\}$ if $x,y > 0$
    \item $-\min\{|x|, |y|\}$ if $x,y < 0$
\end{itemize}
and implemented as follows.
\begin{equation}
    \minmod (x, y) = \sgn'(x) \max\left(0, \min\left(|x|, y \sgn'(x)\right)\right)
\end{equation}
where
\begin{equation}
    \sgn'(x) =
    \begin{dcases*}
        1  & if $x \geq 0$ \\
        -1 & otherwise.
    \end{dcases*}
\end{equation}

Additionally,
\begin{equation}
    \slopefit(\ell, c, r, \theta) = \minmod\left((r - c)\theta,
        \minmod\left(\frac{1}{2}(r - \ell), (c-\ell)\theta\right)\right).
\end{equation}

To carry out each Euler step, the \kinetic solver first communicates the current cell's
boundaries with neighboring MPI cells (described in
Section~\ref{src:kinetic_boundaries.cpp}) and then solves flux for the
cell (described below). For each cell $(i,j)$ in the main grid (excluding the ghost
cells), the integral of $F$ is calculated as
\begin{equation}
    \texttt{integral} \assign
    \frac{\sigma_{S,(i,j)}}{4\pi} \sum_{q=0}^n w_q f_q(i,j)
\end{equation}
where $w_q$ is the calculated quadrature weight for the $q$\textsuperscript{th} point
of an $n$ point Gauss-Legendre quadrature and
$f_q(i,j)$ is the value of the \texttt{c\_kinetic} grid at $(i,j,q)$.

For each $0 \leq q < n$, subtract from the value of \texttt{c\_kinetic} at $(i,j,q)$
\begin{equation} % translate to recurrence relation?
    \Delta t \left(\sigma_{T,(i,j)} (\mathtt{c\_kinetic})_{(i,j,q)} -
    \mathtt{integral}\right).
\end{equation}
Next, if using \texttt{INITCOND\_LATTICE}, with the cell's bottom left point
$(x_i,y_j)$ add an additional $\Delta t$ to \texttt{c\_kinetic} at $(i,j,q)$ if
$\|(x_i,y_j)\|_\infty < 0.5$. Finally, subtract $\Delta t (\mathtt{c\_flux})_{i,j,q}$
from \texttt{c\_kinetic} at $(i,j,q)$.

Communicating boundaries, solving flux, and evaluating an Euler step are carried out
again as above. Now for each $(i,j)$ in the main grid, $0 \leq q < n$, average
\texttt{c\_kinetic} at $(i,j,q)$ with the corresponding cell from the copy made at
the beginning of the procedure.

Solving for flux involves approximating the flux in each of four directions
(north, south, east, west) using
\texttt{slopefit} applied to the current cell and its neighbors. The overall flux for
each cell is then calculated as
\begin{equation}
    \frac{\xi_q}{\Delta x} (\mathtt{eastFlux} - \mathtt{westFlux}) +
    \frac{\eta_q}{\Delta y} (\mathtt{northFlux} - \mathtt{southFlux}).
\end{equation}

\subsubsection{\texttt{kinetic\_boundaries.cpp}}
\label{src:kinetic_boundaries.cpp}
The \kinetic solver uses the code in \texttt{kinetic\_boundaries.cpp} in
conjunction with \texttt{Solver::communicateBoundaries()}
(see Section~\ref{src:comm.cpp}) to coordinate the boundaries of different nodes
when using MPI.
The methods defined here take pointers to buffers from which and into which to copy
grid data. These methods copy the north, south, east, and west parts of the gray
area as shown in Figure~\ref{fig:grid}.

\subsubsection{\texttt{kinetic\_output.cpp}}
\label{src:kinetic_output.cpp}
The \kinetic solver exports data to files named \texttt{out\_\%.3f\_\%d.sn}
formatted with the time under simulation and the node index. This file
consists of a short header recording the dimensions of the grid, the domain bounds,
and the number of quadrature points and weights. The rest of the file contains the
floating point values of \texttt{c\_kinetic} over the main grid (\emph{not}
including the ghost cells).

\section{Special Files \comment{UPDATE ME}}
\label{file}
\subsection{\inputdeck}
\label{file:input.deck}
\inputdeck is the primary input file which controls the basic operation of the program.
\inputdeck is a line-based text file storing a set of runtime configuration options
as an ordered listing of key-value pairs. An example file is included with the source
code. The required options are discussed in Table~\ref{table:input.deck}.
\begin{table}
    \centering
    \caption{Parameters for \inputdeck}
    \label{table:input.deck}

    \vspace{0.5cm}

    \begin{tabu}{c c X[l]}
        Option & Type & Description \\ \hline
        \texttt{SOLVER} & \chars &
            Solver to be used. Allowed values are \kinetic,
            \moment, \momopt, and \dn. The operation
            of each solver is discussed in Section~\ref{solver}. \\
        \texttt{NUM\_CELLS\_X} & \integer &
            Number of grid cells in the $x$ direction \\
        \texttt{NUM\_CELLS\_Y} & \integer &
            Number of grid cells in the $y$ direction \\
        \texttt{NUM\_MPI\_PARTITIONS\_X} & \integer &
            Number of MPI partitions in the $x$ direction \\
        \texttt{NUM\_MPI\_PARTITIONS\_Y} & \integer &
            Number of MPI partitions in the $y$ direction \\
        \texttt{A\_X} & \double &
            $x$ coordinate of the bottom left corner of the grid \\
        \texttt{B\_X} & \double &
            $x$ coordinate of the top right corner of the grid \\
        \texttt{A\_Y} & \double &
            $y$ coordinate of the bottom left corner of the grid \\
        \texttt{B\_Y} & \double &
            $y$ coordinate of the top right corner of the grid \\
        \texttt{T\_FINAL} & \double &
            Duration of the simulation \\
        \texttt{OUT\_DELTA\_T} & \double &
            Temporal resolution of the output files \\
        \texttt{GAUSSIAN\_SIGMA} & \double &
            $\sigma$ used in the initial grid configurations \\
        \texttt{FLOOR} & \double &
            Minimum value that occurs in the grid \\
        \texttt{INIT\_COND} & \integer &
            How the initial grid values are calculated. Allowed values are
            0, 1, and 2, corresponding to \texttt{INITCOND\_LINESOURCE},
            \texttt{INITCOND\_LATTICE}, and \texttt{INITCOND\_PERIODIC},
            respectively. Grid initialization is described in
            Section~\ref{src:main.cpp}. \\
        \texttt{SIGMA} & \double &
            Default scattering used in the $\sigma_S$ and $\sigma_T$
            grids. The scattering values for each grid position are determined
            based on the particular initial condition selected.
    \end{tabu}
\end{table}

\subsection{\kineticdeck}
\label{file:kinetic.deck}
\kineticdeck is a brief runtime configuration file controlling the behavior of the
\kinetic solver. This file uses the same format as
\inputdeck (Section~\ref{file:input.deck}). The required options are given in
Table~\ref{table:kinetic.deck}.
\begin{table}
    \centering
    \caption{Parameters for \kineticdeck}
    \label{table:kinetic.deck}

    \vspace{0.5cm}

    \begin{tabu}{c c X[l]}
        Option & Type & Description \\ \hline
        \texttt{QUAD\_ORDER} & \integer &
            Order of the Gaussian quadrature used for integration \\
        \texttt{CFL\_FACTOR} & \double &
            Parameter used to choose the maximum $\Delta t$ without violating the
            CFL~Condition.
    \end{tabu}
\end{table}




\bibliographystyle{plain}
{\footnotesize
\bibliography{refs}}

\end{document}
